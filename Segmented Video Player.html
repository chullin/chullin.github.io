<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Segmented Video Player</title>
    <style>
      body {
        font-family: system-ui, -apple-system, "Segoe UI", Roboto,
          "Noto Sans TC";
        padding: 18px;
        background: #f7f7f8;
        color: #222;
      }
      .player-wrap {
        max-width: 900px;
        margin: 0 auto;
      }
      video {
        width: 100%;
        height: auto;
        background: #000;
        border-radius: 8px;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
      }
      .info {
        margin-top: 10px;
        display: flex;
        gap: 12px;
        align-items: center;
      }
      .small {
        font-size: 0.9rem;
        color: #555;
      }
      button {
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid #d0d0d5;
        background: #fff;
        cursor: pointer;
      }
      input[type="text"] {
        width: 100%;
        padding: 8px;
        border-radius: 6px;
        border: 1px solid #ddd;
      }
    </style>
  </head>
  <body>
    <div class="player-wrap">
      <h2>Segmented Video Player</h2>

      <!-- 注意：把下面 PLAYLIST_URL 改成你的 m3u8 的實際 URL -->
      <div style="margin-bottom: 8px">
        <label class="small">播放清單（m3u8）URL：</label>
        <input
          id="playlistUrl"
          type="text"
          value="https://chullin.github.io/video_segments/playlist.m3u8"
        />
      </div>

      <video id="player" controls preload="auto"></video>

      <div class="info">
        <div class="small">狀態: <span id="status">準備中</span></div>
        <div class="small">段落: <span id="segIndex">-</span></div>
        <div style="margin-left: auto">
          <button id="reloadBtn">重新載入播放清單</button>
          <button id="playBtn">播放 / 暫停</button>
        </div>
      </div>

      <p class="small" style="margin-top: 10px">
        說明：優先使用 hls.js（若支援）。若不支援 hls，會解析 m3u8 中的 segment
        列表並逐段播放。請確保 m3u8 與 .ts
        檔案在同一個伺服器/同來源（或伺服器允許 CORS）。
      </p>
    </div>

    <!-- hls.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

    <script>
      const player = document.getElementById("player");
      const statusEl = document.getElementById("status");
      const segIndexEl = document.getElementById("segIndex");
      const playlistInput = document.getElementById("playlistUrl");
      const reloadBtn = document.getElementById("reloadBtn");
      const playBtn = document.getElementById("playBtn");

      let hls = null;
      let segments = []; // 當使用 fallback 時，會存放 .ts 列表
      let currentSeg = 0;
      let isPlaying = false;

      async function start() {
        const PLAYLIST_URL = playlistInput.value.trim();
        if (!PLAYLIST_URL) {
          status("請輸入 playlist.m3u8 的 URL");
          return;
        }

        status("檢查 hls 支援性...");
        // 如果瀏覽器支援 hls.js，且 hls.js 可以使用 -> 使用它 (最佳)
        if (window.Hls && Hls.isSupported()) {
          try {
            if (hls) {
              hls.destroy();
              hls = null;
            }
            hls = new Hls();
            hls.loadSource(PLAYLIST_URL);
            hls.attachMedia(player);
            hls.on(Hls.Events.MANIFEST_PARSED, function () {
              status("使用 hls.js 播放 (支援) — 已載入 manifest");
              segIndexEl.textContent = "HLS (manifest)";
              // 自動播放 (若使用者瀏覽器允許)
              // player.play().catch(()=>{});
            });
            hls.on(Hls.Events.ERROR, function (event, data) {
              console.warn("hls.js error", data);
              // 若嚴重錯誤，改用 fallback
              if (data && data.fatal) {
                status("hls.js 發生致命錯誤，改用 fallback");
                hls.destroy();
                hls = null;
                fallbackPlay(PLAYLIST_URL);
              }
            });
            return;
          } catch (e) {
            console.warn("hls init error", e);
          }
        }

        // Apple Safari 原生支援 m3u8
        if (player.canPlayType("application/vnd.apple.mpegurl")) {
          player.src = PLAYLIST_URL;
          status("使用瀏覽器原生 HLS（Safari）播放");
          segIndexEl.textContent = "HLS (native)";
          return;
        }

        // 走 fallback（解析 m3u8 -> 逐段播放）
        fallbackPlay(PLAYLIST_URL);
      }

      async function fallbackPlay(playlistUrl) {
        status("使用 fallback：抓取並解析 m3u8");
        try {
          const res = await fetch(playlistUrl);
          if (!res.ok) throw new Error("抓取 m3u8 失敗: " + res.status);
          const txt = await res.text();
          // 解析：取出非 # 開頭的行（segment uri）
          const lines = txt
            .split(/\r?\n/)
            .map((l) => l.trim())
            .filter((l) => l !== "");
          segments = lines.filter((l) => !l.startsWith("#"));
          if (segments.length === 0) {
            status("播放清單中找不到段落 (.ts)");
            return;
          }
          status("已解析播放清單，共 " + segments.length + " 段");
          segIndexEl.textContent = `0 / ${segments.length}`;
          currentSeg = 0;
          // 開始第一段播放
          await playSegment(currentSeg);
          // 當前段播放結束時，跳到下一段
          player.onended = async () => {
            currentSeg++;
            if (currentSeg < segments.length) {
              await playSegment(currentSeg);
            } else {
              status("已播放完全部段落");
              segIndexEl.textContent = `${segments.length} / ${segments.length}`;
            }
          };
        } catch (err) {
          console.error(err);
          status("fallback 發生錯誤: " + err.message);
        }
      }

      // 將指定段設為 video.src 並嘗試 prefetch 下一段以降低切換延遲
      async function playSegment(index) {
        const segUrl = segments[index];
        if (!segUrl) {
          status("找不到段 " + index);
          return;
        }
        status("正在播放段 " + (index + 1) + " / " + segments.length);
        segIndexEl.textContent = `${index + 1} / ${segments.length}`;

        // 嘗試 prefetch 下一段（非必要）
        const nextUrl = segments[index + 1];
        if (nextUrl) {
          // 用 fetch 先抓但不轉為 blob（以利瀏覽器快取）
          fetch(nextUrl).catch(() => {});
        }

        // 設定 video src 為段檔（假設 .ts 可直接被瀏覽器播放或伺服器回傳可播放容器）
        // 在某些瀏覽器 .ts 直接當作 src 可能不行，但一般 .mp4 segments 或 hls.js 處理較好。
        player.src = segUrl;
        try {
          await player.play();
          isPlaying = true;
        } catch (e) {
          // 使用者互動限制可能阻止自動播放
          isPlaying = false;
        }
      }

      function status(text) {
        statusEl.textContent = text;
        console.log("[player status]", text);
      }

      // UI
      reloadBtn.addEventListener("click", () => start());
      playBtn.addEventListener("click", () => {
        if (!player.src) return;
        if (player.paused) {
          player.play();
        } else {
          player.pause();
        }
      });

      // 自動啟動一次
      start();
    </script>
  </body>
</html>
